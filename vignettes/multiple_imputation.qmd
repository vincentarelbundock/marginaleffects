
# Missing Data

```{r, include = FALSE}
options(width = 1000)
knitr::opts_chunk$set(
  collapse = TRUE,
  fig.width = 9,
  fig.asp = .4,
  out.width = "100%",
  warning = FALSE,
  message = FALSE,
  comment = "#>"
)
```

The `marginaleffects` package offers convenience functions to compute and display predictions, contrasts, and marginal effects from models with multiple imputation from the `mice` and `Amelia` packages. The workflow follows Rubin's rules (Rubin, 1987, p. 76), via the following steps:

1. Impute $M$ data sets.
2. Fit a model in each of the $M$ imputed data sets.
3. Compute marginal effects in each of the $M$ data sets.
4. Pool results.

To highlight the workflow, we consider a simple linear regression model, although the same workflow should work with any model type that is fit using a formula interface and a `data` argument.

`marginaleffects` directly supports the `mice` and `Amelia` imputation packages, as well as any other package that can return a list of imputed data frames. This is demonstrated below using the `iris` dataset, in which we insert missing observations randomly and then impute missing values using several packages.

```{r}
library(marginaleffects)
set.seed(1024)

dat <- iris
dat$Sepal.Length[sample(seq_len(nrow(iris)), 40)] <- NA
dat$Sepal.Width[sample(seq_len(nrow(iris)), 40)] <- NA
dat$Species[sample(seq_len(nrow(iris)), 40)] <- NA
```

## `mice`

First, we impute the dataset using the `mice` package:

```{r}
library(mice)

dat_mice <- mice(dat, m = 20, printFlag = FALSE, .Random.seed = 1024)
```

Then, we use the standard `mice` syntax to produce an object of class `mira` with all the models:

```{r}
mod_mice <- with(dat_mice, lm(Petal.Width ~ Sepal.Length * Sepal.Width + Species))
```

Finally, we feed the `mira` object to a `marginaleffects` function:

```{r}
mfx_mice <- avg_slopes(mod_mice, by = "Species")
mfx_mice
```

## `Amelia`

With `Amelia`, the workflow is essentially the same. First, we impute using `Amelia`:

```{r, include = FALSE}
## no startup messages
library(Amelia)
```
```{r, message = FALSE, warning = FALSE}
library(Amelia)

dat_amelia <- amelia(dat, m = 20, noms = "Species", p2s = 0)
```

Then, we use `Amelia` syntax to produce an object of class `amest` with all the models:

```{r}
mod_amelia <- with(dat_amelia, lm(Petal.Width ~ Sepal.Length * Sepal.Width + Species))
```

Finally, we feed the `amest` object to a `marginaleffects` function:

```{r}
mfx_amelia <- avg_slopes(mod_amelia, by = "Species")
mfx_amelia
```

## Other imputation packages: `missRanger`, or lists of imputed data frames.

Several `R` packages can impute missing data. Indeed, [the `Missing Data CRAN View`](https://cran.r-project.org/web/views/MissingData.html) lists at least a dozen alternatives. Since user interfaces change a lot from package to package, `marginaleffects` supports a single workflow that can be used, with some adaptation, with all imputation packages:

1. Use an external package to create a list of imputed data frames.
2. Apply the `datalist2mids()` function from the `miceadds` package to convert the list of imputed data frames to a `mids` object.
3. Use the `with()` function to fit models to create `mira` object, as illustrated in the `mice` and `Amelia` sections above.
4. Pass the `mira` object to a `marginaleffects` function.
   
Consider the imputation package `missRanger`, which generates a list of imputed datasets:

```{r, include = FALSE}
## no startup messages
library(miceadds)
library(missRanger)
```

```{r, message = FALSE, warning = FALSE}
library(miceadds)
library(missRanger)

## convert lists of imputed datasets to `mids` objects
dat_missRanger <- replicate(20, missRanger(dat, verbose = 0), simplify = FALSE)
mids_missRanger <- datlist2mids(dat_missRanger)

## fit models
mod_missRanger <- with(mids_missRanger, lm(Petal.Width ~ Sepal.Length * Sepal.Width + Species))

## `missRanger` slopes
mfx_missRanger <- avg_slopes(mod_missRanger, by = "Species")
mfx_missRanger
```

## Comparing results with different imputation software

We can use the `modelsummary` package to compare the results with listwise deletion to the results using different imputations software:

```{r}
library(modelsummary)

## listwise deletion slopes
mod_lwd <- lm(Petal.Width ~ Sepal.Length * Sepal.Width + Species, data = dat)
mfx_lwd <- avg_slopes(mod_lwd, by = "Species")

## regression table
models <- list(
    "LWD" = mfx_lwd,
    "mice" = mfx_mice,
    "Amelia" = mfx_amelia,
    "missRanger" = mfx_missRanger)
modelsummary(models, shape = term : contrast + Species ~ model)
```


## Passing new data arguments: `newdata`, `wts`, `by`, etc.

Sometimes we want to pass arguments changing or specifying the data on which we will do our analysis using `marginaleffects`. This can be for reasons such as wanting to specify the values or weights at which we evaluate e.g. `avg_slopes()`, or due to the underlying models not robustly preserving all the original data columns (such as `fixest` objects not saving their data in the fit object making it potentially challenging to retrieve, and even if retrievable it will not include the weights used during fitting as a column as `wts` expects when given a string).

If we are not using multiple imputation, or if we want to just pass a single dataset to the several fitted models after multiple imputation, we can pass a single dataset to the `newdata` argument. However, if we wish to supply each model in our list resulting after multiple imputation with a /different/ dataset on which to calculate results, we cannot use `newdata`. Instead, in this case it can be useful to revert to a more manual (but still very easy) approach. Here is an example calculating `avg_slopes` using a different set of weights for each of the `fixest` models which we fit after multiple imputation.

```{r}
set.seed(1024)
library(mice)
library(fixest)
library(marginaleffects)

dat <- mtcars

## insert missing values
dat$hp[sample(seq_len(nrow(mtcars)), 10)] <- NA
dat$mpg[sample(seq_len(nrow(mtcars)), 10)] <- NA
dat$gear[sample(seq_len(nrow(mtcars)), 10)] <- NA

## multiple imputation
dat <- mice(dat, m = 5, method = "sample", printFlag = FALSE)
dat <- complete(dat, action = "all")

## fit models
mod <- lapply(dat, \(x) 
    feglm(am ~ mpg * cyl + hp,
        weight = ~gear,
        family = binomial,
        data = x))

## slopes without weights
lapply(seq_along(mod), \(i) 
    avg_slopes(mod[[i]], newdata = dat[[i]])) |>
    mice::pool()

## slopes with weights
lapply(seq_along(mod), \(i) 
    avg_slopes(mod[[i]], newdata = dat[[i]], wts = "gear")) |>
    mice::pool()
```


## `newdata` with imputed datasets

In some contexts (ex: Average Treatment effects on the Treated), users want to apply a function like `subset()` to the data in `newdata`. Unfortunately, there is no `subset()` method applicable to `mice`-generated objects. One alternative is to generate estimates for each imputed datasets separately and pool the results after. For example:


```{r}
library(mice)
library(marginaleffects)
data("lalonde_mis", package = "cobalt")

imp <- mice(lalonde_mis, m = 5, print = FALSE)
est <- lapply(1:5, \(i) {
    data <- complete(imp, i)
    mod <- lm(re78 ~ treat * (age + educ + re74), data = data)
    avg_predictions(mod, variables = "treat", newdata = subset(treat == 1))
})
mice::pool(est)
```