---
bibliography: library.bib
---

```{r}
#| cache: false
#| echo: false
source("code/load.R")
```

# Categorical and ordinal outcomes {#sec-categorical}

This chapter shows how the framework and tools introduced in @sec-framework can help us give meaningful interpretation to the estimates obtained by fitting a categorical or ordinal outcome model.

We say that the dependent variable of a regression model is categorical when it is discrete, involves a finite number of categories, but does not have a natural ordering. Categorical outcomes are very common in data analysis, for example, when one wishes to model the choice of a mode of transportation (e.g., car, bus, bike, walk). A popular way to approach such data is to use specify and fit a multinomial logit model. In such a model, the probability of each category $j$ of the outcome variable is modeled as:

We say that the dependent variable of a regression model is ordinal when it is discrete, involves a finite number of categories, and has a natural ordering. Ordinal outcomes are very common in data analysis, for example, when one wishes to model levels of satisfaction (e.g., very dissatisfied, dissatisfied, neutral, satisfied, very satisfied). A popular way to approach such data is to specify and fit an ordered probit model. In such a model, the probability of each category $j$ of the outcome variable is modeled as [@CamTri2005]:

$$P(Y = j) = \Phi(\theta_j - \mathbf{X}\beta) - \Phi(\theta_{j-1} - \mathbf{X}\beta)$$

where $\mathbf{X}$ represents the vector of predictors, $\beta$ the vector of coefficients, $\theta_j$ and $\theta_{j-1}$ the threshold parameters defining the boundaries between categories $j$ and $j-1$, and $\Phi$ the standard normal cumulative distribution function.

The distinguishing feature of models like the multinomial logit or ordered probit is that they estimate different parameters for each level the outcome variable. This allows the analyst to derive different estimates of the quantities of interest (predictions, counterfactual comparisons, and slopes) for each level of the dependent variable. Since many categorical and ordered outcome models share this property, the framework introduced in this book applies in roughly the same way. Therefore, this chapter only considers the ordered probit case, but the same workflow applies to a wide class of models, including other multinomial and ordered approaches.

Let's consider Extramarital Affairs dataset, collected through a survey by Psychology Today in 1969, and analyzed in @Fai1978. These data include 601 observations on various demographic, marital, and personal characteristics: gender, age, years married, presence of children, religiousness, education, occupation, self-rated happiness in marriage, and the frequency of extramarital sexual encounters in the past year. The 'affairs' variable records the self-reported frequency of extramarital sexual encounters in the past year: : 0, 1, 2, 3, 4-10 or <10.

To start, we load the data and plot the distribution of the outcome:

```{r} 
#| label: fig-categorical_barplot
#| fig-cap: Distribution of the self-reported number of extra-marital affairs during 12 months preceding the survey (Fair, 1978).
library(MASS)
library(marginaleffects)
dat <- read.csv("data/affairs.csv")

# The outcome variable needs to be ordered 
dat$affairs <- factor(dat$affairs, unique(dat$affairs))

barplot(table(dat$affairs), ylab = "N", xlab = "Affairs")
```

Now, we fit an ordered probit regression model and summarize the results:

```{r}
# Fit and summarize the model
mod <- polr(
  affairs ~ children + yearsmarried + gender,
  method = "probit", data = dat, Hess = TRUE)
summary(mod)
```

The coefficients in this model can be viewed as measuring a change in a latent variable, but building intuition our model is not straightforward simply by looking at coefficient estimates. Instead, of coefficient estimates, we focus on predictions and counterfactual comparisons, as we have done throughout this book.

## Predictions

The first step in our post-hoc workflow is to compute average predictions, that is, the expected probabilities of each category of the dependent variable, averaged over the observed data. This provides a summary measure of the model's predicted outcomes, offering a more interpretable understanding of the model's overall behavior.

```{r}
p <- avg_predictions(mod)
p
```

Since we are working with a(n ordered) categorical outcome model, the `avg_predictions()` function automatically returns one average predicted probability per outcome level. The group identifiers are available in the `group` column of the output data frame:

```{r}
colnames(p)
p$group
```

Unsurprisingly, given @fig-categorical_barplot, the expected probability that `affairs=0` is much higher than that of any of the other outcome levels.

As we saw in @sec-predictions, it is easy to compute average predictions for different subgroups. For instance, if we want to know the expected probability of each outcome level, for survey respondents with and without children, we simply call:

```{r}
avg_predictions(mod, by = "children")
```

And we can plot these figures with an analogous call. We use the `by` argument to marginalize across combinations of the `group` outcome and `children` predictor:

```{r}
#| label: fig-categorical_plot_predictions
#| fig-cap: Average predicted probabilities for each outcome level, for the subpopulations with and without children.
plot_predictions(mod, by = c("group", "children"))
```

@fig-categorical_plot_predictions shows again that the most likely answer---by far---is zero. Moreover, the graph suggests that there the differences in predicted probabilities between the "yes" and "no" `children` groups is quite small. This impression will be confirmed in the next section, where we discuss counterfactual comparisons.

In some cases, it may be useful to aggregate or combine different outcome level categories. For example, we may want to compute the sum of all predicted probabilities for `group` categories above 0.

One powerful strategy is to define a custom function to use in the `hypothesis` argument of `avg_predictions()`. According to the function manual (`?avg_predictions`), a custom hypothesis function must accept the same data frame that we obtain when calling a function without the `hypothesis` argument, i.e. a data frame with `group`, `term`, and `estimate` columns. The custom function can then process this input and return a data frame with a `term` and an `estimate` column.

For example, this custom function accepts a data frame `x`, collapses the predicted probabilities by group categories, and returns a data frame of new estimates:

```{r}
hyp <- function(x) {
  x$term <- ifelse(x$group == "0", "0", ">1")
  aggregate(estimate ~ term + children, FUN = sum, data = x)
}
avg_predictions(mod, by = "children", hypothesis = hyp)
```

The custom function above applied a sum by subgroup using the `aggregate()` function, which has been available in base `R` since the 20th century. An equivalent `tidyverse` version of this custom function would be:

```{r}
#| eval: false
library(tidyverse)
hyp <- function(x) {
  x %>% 
    mutate(term = if_else(group == "0", "0", ">1")) %>%
    summarize(estimate = sum(estimate), .by = c("term", "children"))
}
avg_predictions(mod, by = "children", hypothesis = hyp)
```

## Counterfactual comparisons

After looking at predictions, we can no move on to counterfactual comparisons. Our first object here is to answer this question: What is the effect of increasing the `yearsmarried` function by 5 years on the average predicted probability of each level of the outcome variable?

```{r} 
avg_comparisons(mod, variables = list(yearsmarried = 5))
```
```{r} 
cmp <- avg_comparisons(mod, variables = list(yearsmarried = 5))
cmp <- sprintf("%.1f", abs(cmp$estimate) * 100)
```

On average, increasing the `yearsmarried` variable by 5 reduces the predicted probability that `affairs=0` by `{r} cmp[1]` percentage points. On average, increasing `yearsmarried` by 5 increases the predicted probability that `affairs>10` by `{r} cmp[6]` percentage points. These counterfactual comparisons are associated with small $p$ values, so we can reject the null hypothesis that `yearsmarried` has no effect on predicted `affairs`.

In contrast, if we estimate the effect of manipulating the `gender` variable, we find that differences in predicted probabilities are small and statistically insignificant. We cannot reject the null hypothesis that `gender` has no effect on `affairs`.

```{r} 
#| warning: false
avg_comparisons(mod, variables = "gender")
```

