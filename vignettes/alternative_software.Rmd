---
title: "Comparisons to alternative software" 
output: rmarkdown::html_vignette
vignette: >
  %\VignetteIndexEntry{Comparisons to alternative software}
  %\VignetteEngine{knitr::rmarkdown}
  %\VignetteEncoding{UTF-8}
---

```{r, include = FALSE}
knitr::opts_chunk$set(
  collapse = TRUE,
  fig.width = 6,
  fig.asp = .4,
  warning = FALSE,
  message = FALSE,
  comment = "#>"
)
```

If you do not like `marginaleffects`, you may want to consider one of the alternatives described below:

* `margins`: https://cran.r-project.org/web/packages/margins/index.html
* `prediction`: https://cran.r-project.org/web/packages/prediction/index.html
* `emmeans`: https://cran.r-project.org/web/packages/emmeans/index.html
* `effects`: https://cran.r-project.org/web/packages/effects/index.html
* `modelbased`: https://easystats.github.io/modelbased/
* `ggeffects`: https://strengejacke.github.io/ggeffects/
* `Stata` by StataCorp LLC

# `Stata`

`Stata` is a good but expensive software package for statistical analysis. It is published by StataCorp LLC. This section compares `Stata`'s `margins` command to `marginaleffects`.

The results produced by `marginaleffects` are extensively tested against `Stata`. See the [test suite](https://github.com/vincentarelbundock/marginaleffects/tree/main/tests/testthat/stata) for a list of the dozens of models where we compared estimates and standard errors.

## Average Marginal Effect (AMEs)

Marginal effects are unit-level quantities. To compute "average marginal effects", we first calculate marginal effects for each observation in a dataset. Then, we take the mean of those unit-level marginal effects. 

### Stata

Both Stata's `margins` command and the `marginaleffects` function can calculate average marginal effects (AMEs). Here is an example showing how to estimate AMEs in Stata: 

```
quietly reg mpg cyl hp wt
margins, dydx(*)

Average marginal effects                        Number of obs     =         32
Model VCE    : OLS
 
Expression   : Linear prediction, predict()
dy/dx w.r.t. : cyl hp wt
 
------------------------------------------------------------------------------
    |            Delta-method
    |      dy/dx   Std. Err.      t    P>|t|     [95% Conf. Interval]
------------------------------------------------------------------------------
cyl |  -.9416168   .5509164    -1.71   0.098    -2.070118    .1868842
 hp |  -.0180381   .0118762    -1.52   0.140    -.0423655    .0062893
 wt |  -3.166973   .7405759    -4.28   0.000    -4.683974   -1.649972
------------------------------------------------------------------------------
```

### marginaleffects

The same results can be obtained with `marginaleffects()` and `summary()` like this:

```{r}
library("marginaleffects")
mod <- lm(mpg ~ cyl + hp + wt, data = mtcars)
mfx <- marginaleffects(mod)
summary(mfx)
```

Note that `Stata` reports t statistics while `marginaleffects` reports Z. This produces slightly different p-values because this model has low degrees of freedom: `mtcars` only has 32 rows

## Counterfactual Marginal Effects

A "counterfactual marginal effect" is a special quantity obtained by replicating a dataset while fixing some regressor to user-defined values.

Concretely, Stata computes counterfactual marginal effects in 3 steps:

  1. Duplicate the whole dataset 3 times and sets the values of `cyl` to the three specified values in each of those subsets.
  2. Calculate marginal effects for each observation in that large grid.
  3. Take the average of marginal effects for each value of the variable of interest. 

### Stata

With the `at` argument, Stata's `margins` command estimates average _counterfactual_ marginal effects. Here is an example:

```
quietly reg mpg i.cyl##c.hp wt
margins, dydx(hp) at(cyl = (4 6 8))

Average marginal effects                        Number of obs     =         32
Model VCE    : OLS

Expression   : Linear prediction, predict()
dy/dx w.r.t. : hp

1._at        : cyl             =           4

2._at        : cyl             =           6

3._at        : cyl             =           8

------------------------------------------------------------------------------
             |            Delta-method
             |      dy/dx   Std. Err.      t    P>|t|     [95% Conf. Interval]
-------------+----------------------------------------------------------------
hp           |
         _at |
          1  |   -.099466   .0348665    -2.85   0.009    -.1712749   -.0276571
          2  |  -.0213768    .038822    -0.55   0.587    -.1013323    .0585787
          3  |   -.013441   .0125138    -1.07   0.293    -.0392137    .0123317
------------------------------------------------------------------------------
```

<!-- Adapted from this GitHub issue: https://github.com/strengejacke/ggeffects/issues/249 -->

### marginaleffects

You can estimate average counterfactual marginal effects with `marginaleffects()` by, first, setting the `grid.type` argument of `data.grid()` to `"counterfactual"` and, second, by telling the `summary` function that you want to average within groups:

```{r}
mod <- lm(mpg ~ as.factor(cyl) * hp + wt, data = mtcars)

mfx <- marginaleffects(
    mod,
    variables = "hp",
    newdata = datagrid(cyl = c(4, 6, 8),
                       grid.type = "counterfactual"))

summary(mfx, by = "cyl")
```

This is equivalent to taking the group-wise mean of observation-level marginal effects:

```{r}
library(dplyr)
mfx %>% group_by(term, cyl) %>% summarize(dydx = mean(dydx))
```

<!-- Taken from https://github.com/vincentarelbundock/marginaleffects/issues/226 -->

Note that following `Stata`, the standard errors for group-averaged marginal effects are computed by taking the "Jacobian at the mean:" 


```{r}
J <- attr(mfx, "J")
J_mean <- aggregate(J, by = list(mfx$cyl), FUN = mean)
J_mean <- as.matrix(J_mean[, 2:ncol(J_mean)])
sqrt(diag(J_mean %*% vcov(mod) %*% t(J_mean)))
```

## Average Counterfactual Adjusted Predictions

### Stata

Just like Stata's `margins` command computes average counterfactual marginal effects, it can also estimate _average counterfactual adjusted predictions_.  

Here is an example:

```
quietly reg mpg i.cyl##c.hp wt
margins, at(cyl = (4 6 8))

Predictive margins                              Number of obs     =         32
Model VCE    : OLS

Expression   : Linear prediction, predict()

1._at        : cyl             =           4

2._at        : cyl             =           6

3._at        : cyl             =           8

------------------------------------------------------------------------------
             |            Delta-method
             |     Margin   Std. Err.      t    P>|t|     [95% Conf. Interval]
-------------+----------------------------------------------------------------
         _at |
          1  |   17.44233   2.372914     7.35   0.000     12.55522    22.32944
          2  |    18.9149   1.291483    14.65   0.000     16.25505    21.57476
          3  |   18.33318   1.123874    16.31   0.000     16.01852    20.64785
------------------------------------------------------------------------------
```

Again, this is what Stata does in the background:

  1. It duplicates the whole dataset 3 times and sets the values of `cyl` to the three specified values in each of those subsets.
  2. It calculates predictions for that large grid.
  3. It takes the average prediction for each value of `cyl`.
  
In other words, average counterfactual adjusted predictions as implemented by Stata are a hybrid between predictions at the observed values (the default in `marginaleffects::predictions`) and predictions at representative values. 

### marginaleffects

You can estimate average counterfactual adjusted predictions with `predictions()` by, first, setting the `grid.type` argument of `data.grid()` to `"counterfactual"` and, second, by averaging the predictions, for example using `aggregate()` or `dplyr::summarise()`.

```{r}
mod <- lm(mpg ~ as.factor(cyl) * hp + wt, data = mtcars)


pred <- predictions(mod,
                    newdata = datagrid(cyl = c(4, 6, 8),
                                       grid.type = "counterfactual"))

aggregate(pred$predicted, by = list(pred$cyl), FUN = mean)
```

Note that standard errors are not yet available for average adjusted predictions.

# `margins`

The [`margins`](https://cran.r-project.org/web/packages/margins/index.html) and [`prediction`](https://cran.r-project.org/web/packages/prediction/index.html) packages for `R` were designed by Thomas Leeper to emulate the behavior of the `margins` command from `Stata`. These packages are trailblazers and strongly influenced the development of `marginaleffects`. The main benefits of `marginaleffects` over these packages are:

* Support more model types
* Faster
* Memory efficient
* Plots using `ggplot2` instead of Base R
* More extensive test suite
* Active development

The syntax of the two packages is very similar:

```{r}
library(margins)

mod <- lm(mpg ~ cyl + hp + wt, data = mtcars)

mfx <- margins(mod)
summary(mfx)

mfx <- marginaleffects(mod)
summary(mfx)
```

We can also use `margins` to compute "counterfactual average marginal effects" (see the `Stata` section for identical results):

```{r}
dat <- mtcars
dat$cyl <- factor(dat$cyl)
mod <- lm(mpg ~ cyl * hp + wt, data = mtcars)
margins(mod, at = list(cyl = c(4, 6, 8)))
```

# `emmeans`

The [`emmeans` package](https://cran.r-project.org/web/packages/emmeans/index.html) is developed by Russell V. Lenth and colleagues. It is an extremely powerful package which focuses on the computation of marginal means, but which can also compute slopes. In my (Vincent's) biased opinion, the main benefits of `marginaleffects` over `emmeans`:

* Support more model types
* Simpler and more intuitive user interface
* Easier to compute marginal effects (slopes) for custom grids and continuous regressors
* Common plots are easier to create with the `plot_cap()` and `plot_cme()` functions

Many of `marginaleffects` advantages come down to subjective preferences over user interface. Readers are thus encouraged to try both packages to see which interface they prefer. Please keep in mind that `emmeans` offers many features which are not yet available in `marginaleffects`, including:

* Transformations and link functions
  - `marginaleffects` can compute quantities on different scales with the `type` argument, but `emmeans` offers a richer array of possibilities for back transforms.
* Custom contrasts and linear functions
  - Compare to the `contrast_factor` and `contrast_numeric` arguments of the `marginaleffects::comparisons` function.
* Multiplicity adjustments.
* Joint tests.
* Equivalence tests.
* Various plots.

# `effects`

The [`effects` package](https://cran.r-project.org/eb/packages/effects/index.html) was created by John Fox and colleagues.

+ `marginaleffects` supports 30+ more model types than `effects`.
+ `effects` focuses on the computation of ["adjusted predictions."](https://vincentarelbundock.github.io/marginaleffects/articles/predictions.html) The plots it produces are roughly equivalent to the ones produced by the `plot_cap` and `predictions` functions in `marginaleffects`.
+ `effects` does not appear support marginal effects (slopes), marginal means, or contrasts 
+ `effects` uses Base graphics whereas `marginaleffects` uses `ggplot2`
+ `effects` includes *a lot* of very powerful options to customize plots. In contrast, `marginaleffects` produces objects which can be customized by chaining `ggplot2` functions. Users can also call `plot_cap(model, draw=FALSE)` to create a prediction grid, and then work the raw data directly to create the plot they need

`effects` offers several options which are not currently available in `marginaleffects`, including:

* Partial residuals plots
* Many types of ways to plot adjusted predictions: [package vignette](https://cran.r-project.org/web/packages/effects/vignettes/predictor-effects-gallery.pdf)

# `modelbased`

The [`modelbased` package](https://easystats.github.io/modelbased/) is developed by the `easystats` team.

This section is incomplete; contributions are welcome.

* Wrapper around `emmeans` to compute marginal means and marginal effects.
* Powerful functions to create beautiful plots.

# `ggeffects`

The [`ggeffects`](https://strengejacke.github.io/ggeffects/) package is developed by Daniel LÃ¼decke.

This section is incomplete; contributions are welcome.

* Wrapper around `emmeans` to compute marginal means.

