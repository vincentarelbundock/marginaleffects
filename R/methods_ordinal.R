#' @rdname get_predict
#' @export
get_predict.clm <- function(
    model,
    newdata = insight::get_data(model),
    type = "prob",
    ...) {
    # `predict.clm()` only makes predictions for the observed response group of
    # each observation in `newdata`. When we remove the response from
    # `newdata`, `predict.clm()` makes predictions for all levels, which is
    # what we want.
    resp <- insight::find_response(model)

    # otherwise `predict.clm` does not see some columns (mystery)
    # copy to avoid breakage in get_comparisons()
    newdata <- as.data.frame(newdata)

    newdata <- newdata[, setdiff(colnames(newdata), resp), drop = FALSE]

    pred <- stats::predict(model, newdata = newdata, type = type)

    contenders <- c("fit", "eta1", "eta2", "cprob1", "cprob2")
    tmp <- NULL
    for (con in contenders) {
        if (is.null(tmp) && con %in% names(pred)) {
            tmp <- pred[[con]]
        }
    }
    pred <- tmp

    out <- data.table(
        group = rep(colnames(pred), each = nrow(pred)),
        estimate = c(pred)
    )
    out$group <- group_to_factor(out$group, model)
    out <- add_rowid(out, newdata)
    return(out)
}

#' @include get_group_names.R
#' @rdname get_group_names
#' @export
get_group_names.clm <- get_group_names.polr


#' @include sanity_model.R
#' @rdname sanitize_model_specific
#' @keywords internal
sanitize_model_specific.clm <- function(model, ...) {
    # Corner case: The `predict.clm` method does not make predictions when the
    # response was transformed to a factor in the formula AND the response is
    # missing from `newdata`.
    lhs <- names(attr(stats::terms(model), "dataClasses"))[1]
    if (isTRUE(grepl("^factor\\(", lhs))) {
        stop(
            "The response variable should not be transformed to a factor in the formula. Please convert the variable to factor before fitting your model.",
            call. = FALSE
        )
    }
    return(model)
}


#' @include set_coef.R
#' @rdname set_coef
#' @export
set_coef.clmm2 <- function(model, coefs, ...) {
    # clmm2 models store coefficients in multiple places:
    # - model$beta: fixed effects only (named vector)
    # - model$Alpha (also Theta, xi): threshold parameters (named vector)
    # - model$coefficients: all parameters including thresholds, fixed effects, and random SD
    idx_alpha <- seq_len(length(model$Alpha))
    idx_beta <- seq_len(length(model$beta)) + length(model$Alpha)
    model$coefficients[seq_len(length(coefs))] <- coefs
    model$Alpha <- coefs[idx_alpha]
    model$beta <- coefs[idx_beta]
    return(model)
}


#' @include get_coef.R
#' @rdname get_coef
#' @export
get_coef.clmm2 <- function(model, ...) {
    out <- c(model$Alpha, model$beta)
    return(out)
}
